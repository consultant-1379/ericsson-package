#!/usr/bin/python

import sys
from subprocess import Popen, STDOUT, PIPE
from argparse import ArgumentParser, RawTextHelpFormatter
import pwd
import os
from os.path import join
import logging
import time

SCRIPTS_LOCATION = '/etc/sysconfig/network-scripts/'
SCRIPTS_BACKUP_LOCATION = '/tmp/network-scripts-backup/'
ETC_LOCATION = '/etc/'
SYS_CLASS_NET_LOCATION = '/sys/class/net/'
FS_TAB_FILE = '/etc/fstab'
RHEL_OS_LOCATION = '/RHEL/os/'
MNT_LOCATION = '/mnt/x86_64/'


class Configurator(object):
    timestamp = time.strftime("%Y%m%d-%H%M%S-%Z")

    def __init__(self):
        super(Configurator, self).__init__()
        logging.basicConfig(format='%(asctime)s [configurator.py] %(message)s',
                            level=logging.INFO,
                            filename='configurator-{0}.log'.format(
                                    self.timestamp),
                            filemode='w')
        c_handler = logging.StreamHandler()
        c_handler.setLevel(logging.INFO)
        c_format = logging.Formatter('%(asctime)s '
                                      '[configurator.py] %(message)s')
        c_handler.setFormatter(c_format)
        logging.getLogger().addHandler(c_handler)

    def configure_networking(self, _sed, node):
        from netaddr import IPNetwork
        services = IPNetwork(_sed.get('ENMservices_subnet'))
        internal = IPNetwork(_sed.get('internal_subnet'))
        internal_ip = None
        external_ip = None

        if 'node1' in node:
            internal_ip = str(_sed.get('gi-node1-int'))
            external_ip = str(_sed.get('gi-node1-ext'))
        elif 'node2' in node:
            internal_ip = str(_sed.get('gi-node2-int'))
            external_ip = str(_sed.get('gi-node2-ext'))
        else:
            logging.warning('WARNING: Please use -n node1 / node2')
            raise ValueError('Please use -n node1 / node2')

        logging.info('INFO: Backing up network-script files to '
                     '/tmp/network-scripts-backup')
        self.backup_network_scripts()

        logging.info('INFO: Generating LACP files')
        self.generate_lacp_files()

        logging.info('INFO: Generating bond files')
        self.generate_bonding_files(internal, services,
                                    _sed, internal_ip, external_ip)

        logging.info('INFO: Generating resolv.conf file')
        self.generate_resolv_conf(_sed)

        logging.info('INFO: Disabling PXE interface')
        self.remove_pxe_interface(_sed, node)

        logging.info('INFO: Stopping NetworkManager')
        self.exec_process(['systemctl', 'stop', 'NetworkManager'])

        logging.info('INFO: Disabling NetworkManager')
        self.exec_process(['systemctl', 'disable', 'NetworkManager'])

        logging.info('INFO: Stopping network.service and restarting network')
        os.system('systemctl stop network.service && service network restart')

    def backup_network_scripts(self):
        self.exec_process(['/bin/mkdir', '-p', SCRIPTS_BACKUP_LOCATION])
        out = self.exec_process(['ls', SCRIPTS_LOCATION])
        files = out.split('\n')
        for f in files:
            if f is '':
                files.remove(f)
            else:
                self.copy(join(SCRIPTS_LOCATION, f), SCRIPTS_BACKUP_LOCATION)

    def get_10gb_interface_names(self):
        lacp_interfaces = []
        out = self.exec_process(['ls', SYS_CLASS_NET_LOCATION])
        interfaces = out.split('\n')
        for inf in interfaces:
            if inf is '' or 'master' in inf:
                interfaces.remove(inf)

        for interface in interfaces:
            proc1 = Popen(['ethtool', interface], stdout=PIPE)
            proc2 = Popen(['grep', '-i', 'speed'], stdin=proc1.stdout,
                          stdout=PIPE)
            proc1.stdout.close()
            out = proc2.communicate()[0].rstrip()
            if 'Speed' in out and '10000' in out:
                lacp_interfaces.append(interface)

        return lacp_interfaces

    def generate_resolv_conf(self, _sed):
        nameserver_a = _sed.get('nameserverA')
        nameserver_b = _sed.get('nameserverB')

        loc = join(ETC_LOCATION, 'resolv.conf')
        content = '# Automatically generated by LocationInsights\n'
        content += 'search {0}\n'.format(_sed.get('dns_domainName'))

        if nameserver_a is not None:
            content += 'nameserver {0}\n'.format(nameserver_a)
        if nameserver_b is not None:
            content += 'nameserver {0}\n'.format(nameserver_b)

        self.writefile(content, loc)

    def generate_lacp_files(self):
        for interface in self.get_10gb_interface_names():
            loc = join(SCRIPTS_LOCATION, 'ifcfg-{0}'.format(interface))
            content = 'BOOTPROTO=static\n'
            content += 'NOZEROCONF=yes\n'
            content += 'USERCTL=no\n'
            content += 'ONBOOT=yes\n'
            content += 'DEVICE={0}\n'.format(interface)
            content += 'SLAVE=yes\n'
            content += 'MASTER=bond0\n'

            self.writefile(content, loc)

    def remove_pxe_interface(self, sed, node):
        target_node = None
        if 'node1' in node:
            target_node = sed.get("gi-node1-int")
        elif 'node2' in node:
            target_node = sed.get("gi-node2-int")

        proc1 = Popen(['ip', 'a', 's'], stdout=PIPE)
        proc2 = Popen(['grep', '{0}'.format(target_node)], stdin=proc1.stdout,
                      stdout=PIPE)
        proc1.stdout.close()
        out = proc2.communicate()[0].rstrip()
        result = out.split()
        if 'bond' in result[len(result)-1]:
            logging.info('INFO: Bonding already configured!')
        else:
            try:
                self.exec_process(['ifdown', result[len(result)-1]])
                os.remove(join(SCRIPTS_LOCATION, 'ifcfg-{0}'.format(
                        result[len(result)-1])))
            except IOError as e:
                logging.error('ERROR: Couldn\'t remove ifcfg-{0}\n{1}'.format(len(result)-1), e)

    def generate_bonding_files(self, internal, services, _sed,
                               internal_ip, external_ip):
        services_netmask = services.netmask
        services_broadcast = services.broadcast
        internal_broadcast = internal.broadcast
        services_vlan_id = _sed.get('VLAN_ID_services')
        services_gateway = _sed.get('ENMservices_gateway')
        zero_addr = '0.0.0.0'

        bond0_location = join(SCRIPTS_LOCATION, 'ifcfg-bond0')
        bond0_tagged_location = join(SCRIPTS_LOCATION,
                                     'ifcfg-bond0.{0}'.format(
                                             services_vlan_id))
        route_file_location = join(SCRIPTS_LOCATION, 'route-bond0.{0}'.format(
                services_vlan_id))

        bond_content = 'ONBOOT=yes\n'
        bond_content += 'STP=off\n'
        bond_content += 'TYPE=Bonding\n'
        bond_content += 'USERCTL=no\n'
        bond_content += 'BROADCAST={0}\n'.format(str(internal_broadcast))
        bond_content += 'DEVICE=bond0\n'
        bond_content += 'NOZEROCONF=yes\n'
        bond_content += 'HOTPLUG=no\n'
        bond_content += 'IPADDR={0}\n'.format(internal_ip)
        bond_content += 'PREFIX={0}\n'.format(internal.prefixlen)
        bond_content += 'DEFROUTE=yes\n'
        bond_content += 'IPV4_FAILURE_FATAL=no\n'
        bond_content += 'IPV6INIT=no\n'
        bond_content += 'BONDING_OPTS="miimon=100 mode=4' \
                        ' xmit_hash_policy=layer3+4"\n'
        self.writefile(bond_content, bond0_location)

        tagged_bond_content = 'ONBOOT=yes\n'
        tagged_bond_content += 'VLAN=yes\n'
        tagged_bond_content += 'BOOTPROTO=static\n'
        tagged_bond_content += 'NETMASK={0}\n'.format(str(services_netmask))
        tagged_bond_content += 'USERCTL=no\n'
        tagged_bond_content += 'BROADCAST={0}\n'.format(str(services_broadcast))
        tagged_bond_content += 'IPADDR={0}\n'.format(external_ip)
        tagged_bond_content += 'DEVICE=bond0.{0}\n'.format(services_vlan_id)
        tagged_bond_content += 'NOZEROCONF=yes\n'
        tagged_bond_content += 'HOTPLUG=no\n'
        self.writefile(tagged_bond_content, bond0_tagged_location)

        self.writefile('ADDRESS0={0} NETMASK0={0} GATEWAY0={1}'.format(
                zero_addr, services_gateway), route_file_location)

    def generate_sed_template(self, sed=None):
        keys = ["ENMservices_subnet", "ENMservices_gateway", "internal_subnet",
                "VLAN_ID_services", "nameserverA", "nameserverB",
                "dns_domainName", "gi-node1-int", "gi-node1-ext",
                "gi-node2-int", "gi-node2-ext", "timezone"]
        file_location = "sed_template.cfg"
        self.writefile("# Auto-generated SED file for LocationInsights\n",
                       file_location)
        for key in keys:
            if sed is not None:
                if sed.get(key) is not None:
                    self.writefile(
                            '{0}={1}'.format(key, sed.get("{0}".format(key))),
                            file_location, True)
                else:
                    self.writefile('{0}='.format(key), file_location, True)
            else:
                self.writefile('{0}='.format(key), file_location, True)

        current_dir = os.getcwd()
        logging.info('INFO: Sed template successfully generated - {0}'.format(join(
                current_dir.strip(), 'sed_template.cfg')))

    def configure_yum(self, iso_path):
        rhel_iso_path = iso_path
        repofile_name = 'os'
        try:
            self.extract_iso(rhel_iso_path, RHEL_OS_LOCATION)
            self.create_repofile(repofile_name, RHEL_OS_LOCATION)

            if self.exists('/etc/yum.repos.d/{0}.repo'.format(repofile_name)):
                logging.info('INFO: Refreshing yum repolist '
                             '[this might take some time]..')
                self.exec_process(['yum', 'clean', 'all'])
                logging.info(self.exec_process(['yum', 'repolist']))
        except Exception as e:
            logging.error("ERROR: Failed to extract iso, {}".format(e))

    def extract_iso(self, iso_path, destination_path):
        logging.info('INFO: Creating /mnt directory')
        self.mkdir(MNT_LOCATION)

        logging.info('INFO: Mounting {0}'.format(iso_path))
        try:
            self.exec_process(['umount', '-f', MNT_LOCATION])
        except:
            pass
        self.exec_process(['mount', '-o', 'loop', '{0}'.format(iso_path),
                           MNT_LOCATION])

        logging.info('INFO: Creating {0} directory'.format(destination_path))
        self.mkdir(destination_path)

        logging.info('INFO: Cloning iso content [this might take some time]..')
        self.exec_process(['/bin/cp', '-r', MNT_LOCATION, destination_path])

        logging.info('INFO: Unmounting {0}'.format(iso_path))
        self.exec_process(['umount', MNT_LOCATION])
        self.exec_process(['/bin/rm', '-rf', '/mnt/'])

    def create_repofile(self, name, path):
        repo_path = '/etc/yum.repos.d/{0}.repo'.format(name)
        self.writefile('[{0}]'.format(name), repo_path)
        self.writefile('name={0} packages'.format(name), repo_path, True)
        self.writefile('baseurl=file://{0}x86_64/'.format(path),
                       repo_path, True)
        self.writefile('enabled=1', repo_path, True)
        self.writefile('gpgcheck=0', repo_path, True)

    def configure_timezone(self, timezone):
        try:
            self.exec_process(['timedatectl', 'set-timezone', timezone])
            logging.info('INFO: Timezone successfully '
                         'set to {0}'.format(timezone))
            logging.getLogger('configurator-{0}.log'.format(
                    self.timestamp)).removeHandler('configurator-{0}.log'
                                                   .format(self.timestamp))
            new_timestamp = time.strftime("%Y%m%d-%H%M%S-%Z")
            os.rename('configurator-{0}.log'.format(self.timestamp),
                      'configurator-{0}.log'.format(new_timestamp))
            logging.getLogger().addHandler(
                    logging.FileHandler('configurator-{0}.log'.format(
                            new_timestamp), mode='a'))
        except IOError:
            logging.error('ERROR: Failed to set timezone {0}'.format(timezone))

    def mount(self):
        try:
            self.exec_process(['mount', '-a'])
        except IOError:
            logging.error('ERROR - '
                          '{0}'.format(self.exec_process(['mount', '-a'])))

    def unmount(self, mount_point):
        try:
            self.exec_process(['umount', mount_point])
        except IOError:
            logging.error('ERROR: {0} not mounted'.format(mount_point))

    def exists(self, path):
        try:
            self.exec_process(['ls', '{0}'.format(path)])
            return True
        except IOError:
            return False
        except OSError:
            return False

    def mkdir(self, dir_path):
        try:
            self.exec_process(['/bin/ls', dir_path])
        except IOError as error:
            if error.args[0] == 2:
                self.exec_process(['/bin/mkdir', '-p', dir_path])
            else:
                raise

    @staticmethod
    def writefile(content, path, append=False):
        f = open(path, "a" if append else "w")
        f.write(content + '\n')
        f.close()

    @staticmethod
    def exec_process(command):
        """
        Execute a system process.
        :param command: The command to execute
        :type command: str[]
        :return:
        """
        process = Popen(command, stderr=STDOUT, stdout=PIPE)
        stdout = process.communicate()[0]
        if process.returncode != 0:
            raise IOError(process.returncode, stdout, command)
        return stdout

    def copy(self, source, target):
        self.exec_process(['/bin/cp', source, target])

    @staticmethod
    def get_username():
        return pwd.getpwuid(os.getuid())[0]

    def install_packages(self):
        packages = ['vim', 'net-tools', 'bind-utils']
        for package in packages:
            try:
                self.exec_process(['yum', 'install', '-y', '{0}'.format(
                        package)])
                logging.info('INFO: Successfully '
                             'installed {0}'.format(package))
            except IOError:
                logging.error('ERROR: There was a problem '
                              'with installing: {0}'.format(package))
                continue

    def configure_fstab(self):
        f = open(FS_TAB_FILE, "r")
        file_content = []

        for line in f:
            if '/opt' in line:
                file_content.append(line.strip().replace('defaults', 'rw,prjquota'))
            else:
                file_content.append(line.strip())

        f.close()
        f = open(FS_TAB_FILE, "w")
        for i in file_content:
            f.writelines(i+'\n')
        f.close()

        try:
            self.exec_process(['umount', '/opt'])
            self.exec_process(['mount', '/opt'])
            logging.info("INFO: Successfully configured /opt mountpoint")
        except Exception as e:
            logging.error("ERROR: Could not re-mount /opt, please restart "
                          "the server manually.\n{0}".format(e))

    def install_data_retention(self):
        logging.info("INFO: Installing data retention script\n")
        path_builder = os.path.realpath(__file__).split('/')
        path_builder = path_builder[:len(path_builder)-2]
        path_builder.append('ldb4-prune')
        path_builder.append('ldb4-prune.sh')
        ldb4_script_path = ''
        for i in path_builder:
            ldb4_script_path += '/{0}'.format(i)

        ldb4_script_path = ldb4_script_path[1:]
        logging.info(self.exec_process([ldb4_script_path, 'setup']))


class Sed(dict):

    def __init__(self, sed_file=None, data=None):
        super(Sed, self).__init__()
        if sed_file:
            with open(sed_file, 'rb') as _reader:
                for _line in _reader.readlines():
                    _line = _line.strip()
                    if len(_line) == 0 or _line.startswith(
                            '#') or '=' not in _line:
                        continue
                    key, value = _line.split('=', 1)
                    self[key] = value
        elif data is not None:
            self.update(data)

    def merge(self, sed):
        _merged = self.copy()
        _merged.update(sed)
        return Sed(data=_merged)

    def get_key(self, value):
        for key in self:
            if self[key] == value:
                return key


def load_seds(sed_files):
    from netaddr import IPNetwork
    """
    Method to load sed files passed as command line arguments

    :param sed_files: SED files to be loaded
    :return: Merged SED data
    """
    _ased = Sed(data={})
    for sedfile in sed_files:
        _ased = _ased.merge(Sed(sedfile))
    for _key in _ased.keys():
        if _key.endswith('_subnet'):
            _ipnet = IPNetwork(_ased[_key])
            _prefix = _key.replace('_subnet', '')
            _ased[_prefix + '_netmask'] = str(_ipnet.netmask)
            _ased[_prefix + '_broadcast'] = str(_ipnet.broadcast)
    if 'ENMservices_subnet' in _ased:
        ipnet = IPNetwork(_ased['ENMservices_subnet'])
        _ased['services_netmask'] = str(ipnet.netmask)
        _ased['services_broadcast'] = str(ipnet.broadcast)
    return _ased


def get_arg_parser():
    argparser = ArgumentParser(formatter_class=RawTextHelpFormatter)

    argparser.add_argument('--sed', dest='seds', action='append', nargs='?',
                           help='Path to SED file/s')
    argparser.add_argument('--sed_template', action='store_true',
                           dest='sed_template',
                           help='Generate sed template '
                                'with required keys. ')
    argparser.add_argument('--networking', action='store_true',
                           dest='networking',
                           help='Configure networking only')
    argparser.add_argument('--node', action='append', dest='node',
                           help='[node1 | node2]')
    argparser.add_argument('--iso', action='append', dest='iso',
                           help='Full path to RHEL ISO file')
    argparser.add_argument('--automate', action='store_true', dest='automate',
                           help='Run all configuration stages')

    return argparser


def get_main_args(sys_argv):
    arg_parser = get_arg_parser()
    if len(sys_argv) <= 1:
        arg_parser.print_help()
        exit(2)
    return get_arg_parser().parse_args(sys_argv[1:])


def automate(_args, _sed, _config):
    if not _args.seds:
        logging.warning('WARNING: You must pass in the '
                        'sed. [--sed <path_to_sed>]')
    elif not _args.node:
        logging.warning('WARNING: You must specify which node to generate '
                        'scripts for. [--node node1/node2]')
    else:
        logging.info("---------------------------------------------------")
        logging.info("----------------Configuring networking-------------")
        logging.info("---------------------------------------------------")
        _config.configure_networking(_sed, _args.node)
        logging.info("---------------------------------------------------")
        logging.info("----------------Configuring timezone---------------")
        logging.info("---------------------------------------------------")
        _config.configure_timezone(_sed.get('timezone'))
        logging.info("---------------------------------------------------")
        logging.info("----------------Configuring opt--------------------")
        logging.info("---------------------------------------------------")
        _config.configure_fstab()
        if 'node2' in _args.node:
            logging.info("---------------------------------------------------")
            logging.info("----------------Installing data retention----------")
            logging.info("---------------------------------------------------")
            try:
                _config.install_data_retention()
                logging.info("INFO: Successfully installed data retention"
                             " mechanism")
            except Exception as e:
                logging.error("ERROR: Something went wrong during "
                              "installation of data retention "
                              "script..\n{0}".format(e))
        logging.info("---------------------------------------------------")
        logging.info("----------------Installing packages----------------")
        logging.info("---------------------------------------------------")
        _config.install_packages()
        logging.info("RHEL configured successfully")


def main(args):
    _args = get_main_args(args)
    _config = Configurator()

    if str(_config.get_username()).strip() != 'root':
        logging.warning('WARNING: Only root user can run this script')
        exit(2)

    if _args.sed_template:
        _config.generate_sed_template()
        exit(0)

    logging.info("You have entered the following:")
    logging.info("SED file location - {0}".format(_args.seds))
    logging.info("RHEL ISO file location - {0}".format(_args.iso))
    logging.info("Configuring {0}".format(_args.node))
    confirm = raw_input("Do you want to continue? [y/n]: ")

    if confirm.lower() == 'y':

        if not _config.exists('/RHEL/os/x86_64/'):
            try:
                logging.info('INFO: Installing script dependencies!')
                _config.configure_yum(_args.iso[0])
                try:
                    _config.exec_process(['yum', 'install',
                                          'python-netaddr', '-y'])
                except Exception as e:
                    logging.error('ERROR: Could not install netaddr '
                                  'dependency\n(0}'.format(e))
            except Exception as e:
                logging.error('ERROR: Failed to install netaddr, please pass '
                              'in correct ISO path using --iso '
                              'argument\n{0}'.format(e))
        _config.exec_process(['yum', 'install', 'python-netaddr', '-y'])

        if not _args.seds:
            logging.warning('WARNING: You must pass in the '
                            'sed. [--sed <path_to_sed>]')
            exit(2)
        _sed = load_seds(_args.seds)

        if _args.networking:
            if not _args.node:
                logging.warning('WARNING: You must specify which node to '
                                'generate scripts for. [--node node1/node2]')
            else:
                _config.configure_networking(_sed, _args.node)

        if _args.automate:
            automate(_args, _sed, _config)

    else:
        exit(0)

if __name__ == '__main__':
    main(sys.argv)
